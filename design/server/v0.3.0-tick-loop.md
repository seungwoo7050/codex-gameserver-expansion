# v0.3.0 틱 기반 시뮬레이션 설계

## 목표
- 서버 권위 틱 루프를 고정된 주기로 실행한다(60 TPS).
- 입력 이벤트를 미래 틱에 안전하게 대기시킨 뒤 해당 틱에서만 적용한다.
- 동일 입력 시퀀스에 대해 동일한 상태 스냅샷이 보장되는 결정성을 검증한다.
- 테스트에서 상태를 직렬화하여 재현 가능성을 확인한다.

## 틱 루프/시간 정책
- 고정 틱 간격: `std::chrono::nanoseconds(1'000'000'000 / 60)` ≒ 16ms.
- `Simulation::TickOnce()`는 틱 카운터를 1 증가시키고 해당 틱에 대기 중인 이벤트만 처리한다.
- `Simulation::RunForDuration()`는 wall clock 기반으로 원하는 시간 동안 틱을 반복 실행하며 `sleep_until`로 과도한 CPU 소모를 피한다.
- 틱 번호는 1부터 적용되도록 초기 상태에서 0으로 시작하며, 과거 틱 입력은 즉시 거부한다.

## 입력 구조 및 검증
- 입력 필드: `{user_id, target_tick, delta, sequence}`.
- 검증 위치: `Simulation::EnqueueInput()` 내부에서 즉시 검증 후 큐잉.
- 규칙
  - `target_tick` > 현재 틱: 과거 입력 거부(`stale_tick`).
  - `delta` 범위: [-3, 3] 이외는 거부(`delta_out_of_range`).
  - `sequence`는 사용자별 단조 증가, 0 불가(`sequence_not_monotonic`, `sequence_required`).
  - 사용자/틱당 허용 입력 수: 4개 초과 시 거부(`tick_input_limit`).
- 입력은 `inputs_by_tick_[target_tick]` 벡터에 적재되며 같은 시퀀스 내 순서를 유지하기 위해 `stable_sort`와 `sequence → user_id` 우선순위를 사용한다.

## 상태/직렬화
- 플레이어 상태: `{position, last_sequence}`.
- 입력 적용: `delta`만큼 position 이동 후 마지막 적용 시퀀스를 기록.
- 스냅샷: `{tick, players:[{userId, position, lastSequence}, ...]}` 형태 JSON, `userId` 오름차순으로 정렬해 결정성 유지.

## 테스트 전략
- 단위 테스트
  - 특정 입력 시퀀스 적용 시 최종 스냅샷이 예상 JSON과 일치.
  - 동일 시퀀스 재실행 시 스냅샷 동일(결정성).
- 스케줄/부하 확인
  - `RunForDuration(120ms)` 동안 실행 후 틱 증가량이 6~10 범위인지 검증해 폭주 여부 확인.

## 제한 사항
- 틱 루프는 단일 스레드 동작을 가정하며, 네트워크 통합/멀티 스레드 병렬 처리는 추후 버전에서 확장한다.
- 입력 큐는 메모리에만 존재하며 장기 세션 복구/영속화는 포함하지 않는다.
